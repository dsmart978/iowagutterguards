=== Generated: 2026-01-15T20:17:30.1716127-06:00 ===

=== List Cloudflare Pages Functions files (these control routing) ===


FullName                                                             Length
--------                                                             ------
C:\Users\don_s\Desktop\Iowa Gutter Guards Site\functions\api\lead.js   7252



=== Show contents of code-like files under functions/ ===


----- FILE: C:\Users\don_s\Desktop\Iowa Gutter Guards Site\functions\api\lead.js -----

export async function onRequest(context) {
  const { request, env } = context;

  // Only accept POST
  if (request.method === "GET" || request.method === "HEAD") {
    return new Response("Method Not Allowed. POST a lead to /api/lead.", {
      status: 405,
      headers: {
        "allow": "POST",
        "content-type": "text/plain; charset=utf-8",
        "cache-control": "no-store",
      },
    });
  }
  if (request.method !== "POST") {
    return new Response("Method Not Allowed.", {
      status: 405,
      headers: {
        "allow": "POST",
        "content-type": "text/plain; charset=utf-8",
        "cache-control": "no-store",
      },
    });
  }

  const wantsJson = (request.headers.get("accept") || "").toLowerCase().includes("application/json");
  const ct = (request.headers.get("content-type") || "").toLowerCase();

  const json = (status, obj) =>
    new Response(JSON.stringify(obj, null, 2), {
      status,
      headers: {
        "content-type": "application/json; charset=utf-8",
        "cache-control": "no-store",
      },
    });

  const text = (status, body) =>
    new Response(body, {
      status,
      headers: {
        "content-type": "text/plain; charset=utf-8",
        "cache-control": "no-store",
      },
    });

  const redirect303 = (location) =>
    new Response(null, {
      status: 303,
      headers: { Location: location },
    });

  const pickFirst = (obj, keys) => {
    for (const k of keys) {
      const v = obj[k];
      if (typeof v === "string" && v.trim() !== "") return v.trim();
    }
    return "";
  };

  const toPlainObjectFromFormData = (fd) => {
    const out = {};
    for (const [k, v] of fd.entries()) out[k] = typeof v === "string" ? v : "[file]";
    return out;
  };

  const normalizeLeadFields = (data) => {
    // Your site submits capitalized keys (Name, Email, Phone, Notes). Support both.
    const name = pickFirst(data, ["name", "Name", "full_name", "FullName"]);
    const email = pickFirst(data, ["email", "Email"]);
    const phone = pickFirst(data, ["phone", "Phone", "tel", "Tel"]);
    const city = pickFirst(data, ["city", "City", "town", "Town"]);
    const message = pickFirst(data, ["message", "Message", "notes", "Notes", "note", "Note"]);

    // Honeypot (must exist on form as an empty hidden input)
    const website = pickFirst(data, ["website", "Website", "url", "URL"]);

    // Capture everything else (helps when forms have extra fields)
    const extras = {};
    const skip = new Set([
      "name","Name","full_name","FullName",
      "email","Email",
      "phone","Phone","tel","Tel",
      "city","City","town","Town",
      "message","Message","notes","Notes","note","Note",
      "website","Website","url","URL"
    ]);

    for (const [k, v] of Object.entries(data)) {
      const key = String(k);
      if (skip.has(key)) continue;
      if (typeof v === "string" && v.trim() !== "") extras[key] = v.trim();
    }

    return { name, email, phone, city, message, website, extras };
  };

  const buildEmailText = (lead) => {
    const lines = [];
    lines.push(`Name: ${lead.name || "-"}`);
    lines.push(`Email: ${lead.email || "-"}`);
    lines.push(`Phone: ${lead.phone || "-"}`);
    if (lead.city) lines.push(`City: ${lead.city}`);
    if (lead.message) lines.push(`Notes: ${lead.message}`);

    const extraKeys = Object.keys(lead.extras || {});
    if (extraKeys.length) {
      lines.push("");
      lines.push("Extra fields:");
      for (const k of extraKeys.sort()) lines.push(`${k}: ${lead.extras[k]}`);
    }

    return lines.join("\n");
  };

  const sendResendEmail = async ({ lead, textBody }) => {
    const RESEND_API_KEY = env?.RESEND_API_KEY;
    const LEAD_TO = env?.LEAD_TO;
    const LEAD_FROM = env?.LEAD_FROM;

    if (!RESEND_API_KEY) return { ok: false, status: 500, error: "Missing RESEND_API_KEY env var" };
    if (!LEAD_TO) return { ok: false, status: 500, error: "Missing LEAD_TO env var" };
    if (!LEAD_FROM) return { ok: false, status: 500, error: "Missing LEAD_FROM env var" };

    const subjectCity = lead.city ? ` (${lead.city})` : "";
    const payload = {
      from: LEAD_FROM,
      to: [LEAD_TO],
      subject: `New IGG Lead: ${lead.name || "New Lead"}${subjectCity}`,
      text: textBody,
    };

    // Make replying go to the lead
    if (lead.email) payload.reply_to = lead.email;

    const resp = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${RESEND_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    const bodyText = await resp.text();
    if (!resp.ok) {
      return { ok: false, status: 502, error: `Resend error (${resp.status}): ${bodyText || "(empty response)"}` };
    }

    // Resend returns JSON (typically includes id)
    let parsed = null;
    try { parsed = JSON.parse(bodyText); } catch { parsed = null; }

    return { ok: true, status: 200, data: parsed || { raw: bodyText } };
  };

  try {
    let data = {};

    if (ct.includes("application/json")) {
      data = await request.json();
    } else if (ct.includes("application/x-www-form-urlencoded") || ct.includes("multipart/form-data")) {
      const fd = await request.formData();
      data = toPlainObjectFromFormData(fd);
    } else {
      // Last resort attempt
      try {
        const fd = await request.formData();
        data = toPlainObjectFromFormData(fd);
      } catch {
        return wantsJson ? json(400, { ok: false, error: "Unsupported Content-Type" }) : text(400, "Unsupported Content-Type");
      }
    }

    const lead = normalizeLeadFields(data);

    // Honeypot hit: pretend success, do nothing.
    if (lead.website) {
      console.log("Honeypot hit, dropping lead.");
      return wantsJson ? json(200, { ok: true }) : redirect303("/thanks/");
    }

    // Validation: require name + (email OR phone)
    if (!lead.name || (!lead.email && !lead.phone)) {
      const err = "Missing required fields: name and (email or phone).";
      return wantsJson ? json(400, { ok: false, error: err }) : text(400, err);
    }

    const emailText = buildEmailText(lead);

    console.log("Lead received:", {
      name: lead.name,
      email: lead.email || null,
      phone: lead.phone || null,
      city: lead.city || null,
      extrasCount: Object.keys(lead.extras || {}).length,
    });

    const sent = await sendResendEmail({ lead, textBody: emailText });
    if (!sent.ok) {
      console.error("Resend failed:", sent.error);
      return wantsJson ? json(sent.status, { ok: false, error: sent.error }) : text(sent.status, sent.error);
    }

    // Log Resend id if present, but don't expose it to the public response
    const resendId = sent.data && typeof sent.data === "object" ? sent.data.id : null;
    if (resendId) console.log("Resend id:", resendId);

    return wantsJson ? json(200, { ok: true }) : redirect303("/thanks/");
  } catch (err) {
    const msg = err && typeof err.message === "string" ? err.message : String(err);
    console.error("Unhandled error in /api/lead:", msg, err);
    return wantsJson ? json(500, { ok: false, error: "Internal error", detail: msg }) : text(500, `Internal error: ${msg}`);
  }
}

----- END FILE -----

